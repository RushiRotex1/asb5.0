// COMPATIBILITY-OPTIMIZED Google Apps Script - Fast + Stable
// Deploy this as a web app with:
// - Execute as: Me (script owner)
// - Who has access: Anyone (or Anyone with Google account)

const SPREADSHEET_ID = '1rcR-VPUcsqPcwyPrrLFX_s-0kJB8okXit6RwVa0hbww';
const SHEET_NAME = 'String Builder';

// Dropdown cells and their corresponding ranges
const DROPDOWN_CELLS = [
  'B1', 'B11', 'B16', 'B22', 'B25', 'B30', 'B33', 'B36', 'B42', 'B52', 'B56', 'B62', 'B68'
];

const DROPDOWN_RANGES = {
  'B1': 'String Builder!A2:C10',
  'B11': 'Sheet2!D14:D16',
  'B16': 'Sheet2!B19:B22',
  'B22': 'Sheet2!A19:A20',
  'B25': 'Sheet2!E14:E16',
  'B30': 'Sheet2!C27:C39',
  'B33': 'Sheet2!A47:A75',
  'B36': 'Sheet2!C47:C56',
  'B42': 'Sheet2!D47:D48',
  'B52': 'Sheet2!B47:B68',
  'B56': 'Sheet2!C71:C75',
  'B62': 'Sheet2!E47:E52',
  'B68': 'Sheet2!E53:E55'
};

// COMPATIBILITY: Use simpler caching approach
var cachedSpreadsheet = null;

function getSpreadsheet() {
  if (!cachedSpreadsheet) {
    cachedSpreadsheet = SpreadsheetApp.openById(SPREADSHEET_ID);
  }
  return cachedSpreadsheet;
}

// Enhanced CORS response for better compatibility
function createCORSResponse(content) {
  const output = ContentService.createTextOutput(content);
  output.setMimeType(ContentService.MimeType.JSON);
  
  // COMPATIBILITY: More robust header setting
  try {
    if (typeof output.setHeaders === 'function') {
      output.setHeaders({
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS, PUT, DELETE',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With, Accept',
        'Access-Control-Max-Age': '86400',
        'Access-Control-Allow-Credentials': 'false'
      });
    }
  } catch (e) {
    console.log('Headers not supported in this version');
  }
  
  return output;
}

function doOptions(e) {
  console.log('OPTIONS request received');
  return createCORSResponse(JSON.stringify({"status": "ok"}));
}

function doGet(e) {
  console.log('GET Request received');
  return handleRequest(e);
}

function doPost(e) {
  console.log('POST Request received');
  if (e && e.postData) {
    console.log('POST Data type:', e.postData.type);
    console.log('POST Data contents:', e.postData.contents);
  }
  return handleRequest(e);
}

function parseFormData(formData) {
  const params = {};
  const pairs = formData.split('&');
  
  for (let i = 0; i < pairs.length; i++) {
    const pair = pairs[i];
    const [key, value] = pair.split('=');
    if (key && value) {
      params[decodeURIComponent(key)] = decodeURIComponent(value.replace(/\+/g, ' '));
    }
  }
  
  return params;
}

function handleRequest(e) {
  try {
    if (!e) {
      console.error('No event object received');
      return createCORSResponse(JSON.stringify({ 
        success: false, 
        error: 'No request data received' 
      }));
    }
    
    let action = null;
    let postData = null;
    
    // Handle GET parameters
    if (e.parameter) {
      if (e.parameter.action) {
        action = e.parameter.action;
        console.log('Action from URL parameter:', action);
      }
      
      if (e.parameter.cell && e.parameter.value) {
        action = 'updateValue';
        postData = {
          cell: e.parameter.cell,
          value: decodeURIComponent(e.parameter.value)
        };
        console.log('GET-based update detected:', postData);
      }
    }
    
    // Handle POST data
    if (e.postData && e.postData.contents) {
      try {
        if (e.postData.type === 'application/x-www-form-urlencoded') {
          console.log('Processing form data');
          const formParams = parseFormData(e.postData.contents);
          
          if (formParams.data) {
            postData = JSON.parse(formParams.data);
          } else {
            postData = formParams;
          }
        } else {
          console.log('Processing JSON data');
          postData = JSON.parse(e.postData.contents);
        }
        
        if (!action && postData && postData.action) {
          action = postData.action;
        }
        console.log('POST data parsed successfully:', postData);
      } catch (parseError) {
        console.error('Parse Error:', parseError);
        return createCORSResponse(JSON.stringify({
          success: false,
          error: 'Error parsing POST data',
          details: parseError.toString()
        }));
      }
    }
    
    if (!action) {
      console.error('No action specified');
      return createCORSResponse(JSON.stringify({ 
        success: false, 
        error: 'No action specified. Use ?action=actionName or include action in POST body',
        availableActions: ['getLabels', 'getValues', 'getOptions', 'updateValue', 'getResults', 'testConnection', 'clearAllValues', 'getApplicationTypes', 'getCustomRange', 'autoSelectSingleOptions'],
        receivedParams: e.parameter || {},
        hasPostData: !!(e.postData && e.postData.contents)
      }));
    }
    
    let result;
    
    switch (action) {
      case 'getLabels':
        console.log('Executing getLabels');
        result = getDropdownLabels();
        break;
        
      case 'getValues':
        console.log('Executing getValues');
        result = getDropdownValues();
        break;
        
      case 'getOptions':
        console.log('Executing getOptions');
        result = getDropdownOptions();
        break;
        
      case 'updateValue':
        console.log('Executing updateValue with data:', postData);
        if (!postData || !postData.cell || postData.value === undefined) {
          throw new Error('Both cell and value parameters required for updateValue');
        }
        result = updateDropdownValue(postData.cell, postData.value);
        break;
        
      case 'getResults':
        console.log('Executing getResults');
        result = getResults();
        break;
        
      case 'testConnection':
        console.log('Executing testConnection');
        result = { 
          message: 'Connection successful', 
          timestamp: new Date().toISOString(),
          version: 'Compatibility-Optimized Version - Stable + Fast',
          method: e.postData ? 'POST' : 'GET',
          hasParams: !!(e.parameter),
          params: e.parameter || {}
        };
        break;
        
      case 'clearAllValues':
        console.log('Executing clearAllValues');
        result = clearAllDropdownValues();
        break;
        
      case 'getApplicationTypes':
        console.log('Executing getApplicationTypes');
        result = getApplicationTypes();
        break;
        
      case 'getCustomRange':
        console.log('Executing getCustomRange');
        result = getCustomRange();
        break;
        
      case 'autoSelectSingleOptions':
        console.log('Executing autoSelectSingleOptions');
        result = autoSelectSingleOptions();
        break;
        
      default:
        throw new Error('Invalid action: ' + action);
    }
    
    console.log('Action completed successfully');
    return createCORSResponse(JSON.stringify({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    }));
    
  } catch (error) {
    console.error('Script Error:', error);
    return createCORSResponse(JSON.stringify({
      success: false,
      error: error.toString(),
      timestamp: new Date().toISOString()
    }));
  }
}

// COMPATIBILITY: Simplified but still optimized label retrieval
function getDropdownLabels() {
  try {
    const spreadsheet = getSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    
    if (!sheet) {
      throw new Error(`Sheet '${SHEET_NAME}' not found`);
    }
    
    const labels = {};
    
    // COMPATIBILITY: Use traditional approach but batch the operations
    for (let i = 0; i < DROPDOWN_CELLS.length; i++) {
      const cell = DROPDOWN_CELLS[i];
      try {
        const row = parseInt(cell.substring(1));
        const labelValue = sheet.getRange(`A${row}`).getValue();
        labels[cell] = labelValue || `Field ${i + 1}`;
      } catch (cellError) {
        console.error(`Error getting label for ${cell}:`, cellError);
        labels[cell] = `Field ${i + 1}`;
      }
    }
    
    return labels;
  } catch (error) {
    console.error('Error getting labels:', error);
    const fallbackLabels = {};
    DROPDOWN_CELLS.forEach((cell, index) => {
      fallbackLabels[cell] = `Field ${index + 1}`;
    });
    return fallbackLabels;
  }
}

// COMPATIBILITY: Simplified but still optimized value retrieval
function getDropdownValues() {
  try {
    const spreadsheet = getSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    
    if (!sheet) {
      throw new Error(`Sheet '${SHEET_NAME}' not found`);
    }
    
    const values = {};
    
    // COMPATIBILITY: Use traditional approach
    for (let i = 0; i < DROPDOWN_CELLS.length; i++) {
      const cell = DROPDOWN_CELLS[i];
      try {
        const cellValue = sheet.getRange(cell).getValue();
        values[cell] = cellValue ? cellValue.toString() : '';
      } catch (cellError) {
        console.error(`Error getting value for ${cell}:`, cellError);
        values[cell] = '';
      }
    }
    
    return values;
  } catch (error) {
    console.error('Error getting values:', error);
    const emptyValues = {};
    DROPDOWN_CELLS.forEach(cell => {
      emptyValues[cell] = '';
    });
    return emptyValues;
  }
}

function getDropdownOptions() {
  try {
    const spreadsheet = getSpreadsheet();
    const options = {};
    
    for (let cellIndex = 0; cellIndex < DROPDOWN_CELLS.length; cellIndex++) {
      const cell = DROPDOWN_CELLS[cellIndex];
      const range = DROPDOWN_RANGES[cell];
      
      try {
        let sheet, rangeRef;
        
        if (range.includes('!')) {
          const [sheetName, rangeAddress] = range.split('!');
          sheet = spreadsheet.getSheetByName(sheetName);
          rangeRef = rangeAddress;
        } else {
          sheet = spreadsheet.getSheetByName(SHEET_NAME);
          rangeRef = range;
        }
        
        if (!sheet) {
          throw new Error(`Sheet not found in range: ${range}`);
        }
        
        const values = sheet.getRange(rangeRef).getValues();
        const cellOptions = [];
        
        if (cell === 'B1') {
          // Special handling for B1 - get all non-empty values from all columns
          for (let rowIndex = 0; rowIndex < values.length; rowIndex++) {
            const row = values[rowIndex];
            for (let colIndex = 0; colIndex < row.length; colIndex++) {
              const value = row[colIndex];
              if (value !== null && value !== undefined) {
                const stringValue = value.toString().trim();
                if (stringValue !== '' || value === 0) {
                  cellOptions.push(stringValue);
                }
              }
            }
          }
        } else {
          // For other cells, get first column values only
          for (let rowIndex = 0; rowIndex < values.length; rowIndex++) {
            const value = values[rowIndex][0];
            if (value !== null && value !== undefined) {
              const stringValue = value.toString().trim();
              if (stringValue !== '' || value === 0) {
                cellOptions.push(stringValue);
              }
            }
          }
        }
        
        // Remove duplicates and sort if needed
        const uniqueOptions = [];
        for (let i = 0; i < cellOptions.length; i++) {
          if (uniqueOptions.indexOf(cellOptions[i]) === -1) {
            uniqueOptions.push(cellOptions[i]);
          }
        }
        
        // Special sorting for numerical cells
        if (cell === 'B33' || cell === 'B36' || cell === 'B52') {
          try {
            uniqueOptions.sort(function(a, b) {
              const numA = parseFloat(a);
              const numB = parseFloat(b);
              if (!isNaN(numA) && !isNaN(numB)) {
                return numA - numB;
              }
              return a.toString().localeCompare(b.toString());
            });
          } catch (sortError) {
            console.log(`${cell} sorting failed, using original order`);
          }
        }
        
        options[cell] = uniqueOptions;
        
      } catch (error) {
        console.error(`Error fetching options for ${cell}:`, error);
        options[cell] = [`Option 1 for ${cell}`, `Option 2 for ${cell}`];
      }
    }
    
    return options;
  } catch (error) {
    console.error('Error getting dropdown options:', error);
    const defaultOptions = {};
    DROPDOWN_CELLS.forEach(cell => {
      defaultOptions[cell] = ['Option 1', 'Option 2', 'Option 3'];
    });
    return defaultOptions;
  }
}

// COMPATIBILITY: Simplified but reliable update
function updateDropdownValue(cell, value) {
  try {
    console.log(`Attempting to update ${cell} with value:`, value);
    
    if (DROPDOWN_CELLS.indexOf(cell) === -1) {
      throw new Error(`Invalid cell: ${cell}. Valid cells are: ${DROPDOWN_CELLS.join(', ')}`);
    }
    
    const spreadsheet = getSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    
    if (!sheet) {
      throw new Error(`Sheet '${SHEET_NAME}' not found`);
    }
    
    const cellRange = sheet.getRange(cell);
    
    // COMPATIBILITY: Simple, reliable approach
    try {
      cellRange.setValue(value);
      const updatedValue = cellRange.getValue();
      
      console.log(`Successfully updated ${cell}. New value:`, updatedValue);
      
      return { 
        success: true, 
        cell: cell, 
        value: value,
        updatedValue: updatedValue ? updatedValue.toString() : '',
        timestamp: new Date().toISOString(),
        method: 'compatible_direct'
      };
    } catch (directError) {
      console.log(`Direct update failed for ${cell}, trying validation method`);
      
      // Fallback with validation handling
      const existingValidation = cellRange.getDataValidation();
      
      if (existingValidation) {
        cellRange.clearDataValidations();
      }
      
      cellRange.setValue(value);
      
      if (existingValidation) {
        cellRange.setDataValidation(existingValidation);
      }
      
      const updatedValue = cellRange.getValue();
      
      return { 
        success: true, 
        cell: cell, 
        value: value,
        updatedValue: updatedValue ? updatedValue.toString() : '',
        timestamp: new Date().toISOString(),
        method: 'compatible_validation_fallback'
      };
    }
  } catch (error) {
    console.error('Error updating value:', error);
    throw new Error(`Failed to update ${cell} with value ${value}: ${error.toString()}`);
  }
}

function getResults() {
  try {
    const spreadsheet = getSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    
    if (!sheet) {
      throw new Error(`Sheet '${SHEET_NAME}' not found`);
    }
    
    const range = sheet.getRange('A75:CB95');
    const values = range.getValues();
    
    const results = [];
    for (let i = 0; i < values.length; i++) {
      const row = [];
      for (let j = 0; j < values[i].length; j++) {
        row.push(values[i][j] ? values[i][j].toString() : '');
      }
      results.push(row);
    }
    
    return results;
  } catch (error) {
    console.error('Error getting results:', error);
    return [];
  }
}

// COMPATIBILITY: Reliable bulk clearing
function clearAllDropdownValues() {
  try {
    console.log('Starting compatible clearAllDropdownValues...');
    const spreadsheet = getSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    
    if (!sheet) {
      throw new Error(`Sheet '${SHEET_NAME}' not found`);
    }
    
    const results = {
      cleared: [],
      failed: [],
      clearedCount: 0,
      totalCells: DROPDOWN_CELLS.length
    };
    
    // COMPATIBILITY: Clear cells one by one but efficiently
    for (let i = 0; i < DROPDOWN_CELLS.length; i++) {
      const cell = DROPDOWN_CELLS[i];
      try {
        const cellRange = sheet.getRange(cell);
        const currentValue = cellRange.getValue();
        
        cellRange.setValue('');
        
        results.cleared.push({
          cell: cell,
          previousValue: currentValue ? currentValue.toString() : '',
          method: 'compatible_clear'
        });
        results.clearedCount++;
        console.log(`✅ Cleared ${cell} (was: "${currentValue}")`);
        
      } catch (cellError) {
        console.error(`❌ Error clearing ${cell}:`, cellError);
        results.failed.push({
          cell: cell,
          error: cellError.toString()
        });
      }
    }
    
    console.log(`✅ Compatible clearing completed: ${results.clearedCount}/${results.totalCells} cells cleared`);
    
    return { 
      success: true, 
      ...results,
      timestamp: new Date().toISOString(),
      message: `Compatible clearing: ${results.clearedCount} out of ${results.totalCells} dropdown cells cleared`,
      version: 'compatible_clearing'
    };
    
  } catch (error) {
    console.error('❌ Error in compatible clearAllDropdownValues:', error);
    throw new Error(`Compatible clear failed: ${error.toString()}`);
  }
}

// COMPATIBILITY: Reliable auto-selection
// OPTIMIZED Google Apps Script - Replace autoSelectSingleOptions function
// This version is much faster and less likely to timeout

function autoSelectSingleOptions() {
  try {
    console.log('Starting optimized autoSelectSingleOptions...');
    const startTime = new Date().getTime();
    
    const results = {
      autoSelected: [],
      skipped: [],
      failed: [],
      executionTime: 0
    };
    
    // OPTIMIZATION 1: Get spreadsheet once
    const spreadsheet = getSpreadsheet();
    const sheet = spreadsheet.getSheetByName(SHEET_NAME);
    
    if (!sheet) {
      throw new Error(`Sheet '${SHEET_NAME}' not found`);
    }
    
    // OPTIMIZATION 2: Get options without calling the full function
    const quickOptions = {};
    const cellsToProcess = [];
    
    // Quick scan for single options only
    DROPDOWN_CELLS.forEach(cell => {
      try {
        const range = DROPDOWN_RANGES[cell];
        if (!range) return;
        
        let targetSheet, rangeRef;
        
        if (range.includes('!')) {
          const [sheetName, rangeAddress] = range.split('!');
          targetSheet = spreadsheet.getSheetByName(sheetName);
          rangeRef = rangeAddress;
        } else {
          targetSheet = sheet;
          rangeRef = range;
        }
        
        if (!targetSheet) return;
        
        // OPTIMIZATION 3: Get small sample to check if single option
        const values = targetSheet.getRange(rangeRef).getValues();
        const nonEmptyValues = [];
        
        if (cell === 'B1') {
          // Special handling for B1
          values.forEach(row => {
            row.forEach(value => {
              if (value !== null && value !== undefined) {
                const stringValue = value.toString().trim();
                if (stringValue !== '') {
                  nonEmptyValues.push(stringValue);
                }
              }
            });
          });
        } else {
          // Regular cells - first column only
          values.forEach(row => {
            const value = row[0];
            if (value !== null && value !== undefined) {
              const stringValue = value.toString().trim();
              if (stringValue !== '') {
                nonEmptyValues.push(stringValue);
              }
            }
          });
        }
        
        const uniqueOptions = [...new Set(nonEmptyValues)];
        
        if (uniqueOptions.length === 1) {
          cellsToProcess.push({
            cell: cell,
            option: uniqueOptions[0]
          });
        } else {
          results.skipped.push({
            cell: cell,
            reason: 'Multiple options available',
            optionCount: uniqueOptions.length
          });
        }
        
      } catch (error) {
        console.error(`Error checking ${cell}:`, error);
        results.failed.push({
          cell: cell,
          error: error.toString()
        });
      }
    });
    
    // OPTIMIZATION 4: Batch process only cells that need auto-selection
    if (cellsToProcess.length > 0) {
      console.log(`Processing ${cellsToProcess.length} cells with single options`);
      
      // Get current values for cells to process
      cellsToProcess.forEach(cellInfo => {
        try {
          const cellRange = sheet.getRange(cellInfo.cell);
          const currentValue = cellRange.getValue();
          
          if (!currentValue || currentValue.toString().trim() === '') {
            // OPTIMIZATION 5: Direct setValue without validation handling
            cellRange.setValue(cellInfo.option);
            
            results.autoSelected.push({
              cell: cellInfo.cell,
              value: cellInfo.option,
              previousValue: ''
            });
            console.log(`✅ Auto-selected ${cellInfo.cell}: "${cellInfo.option}"`);
          } else {
            results.skipped.push({
              cell: cellInfo.cell,
              reason: 'Cell already has value',
              currentValue: currentValue.toString(),
              option: cellInfo.option
            });
          }
        } catch (cellError) {
          results.failed.push({
            cell: cellInfo.cell,
            error: cellError.toString(),
            option: cellInfo.option
          });
          console.error(`❌ Error auto-selecting ${cellInfo.cell}:`, cellError);
        }
      });
    }
    
    const endTime = new Date().getTime();
    results.executionTime = endTime - startTime;
    
    console.log(`Optimized auto-selection completed in ${results.executionTime}ms: ${results.autoSelected.length} selected, ${results.skipped.length} skipped, ${results.failed.length} failed`);
    
    return {
      success: true,
      autoSelected: results.autoSelected,
      skipped: results.skipped,
      failed: results.failed,
      executionTime: results.executionTime,
      timestamp: new Date().toISOString(),
      summary: `Optimized auto-selected ${results.autoSelected.length} single-option dropdowns in ${results.executionTime}ms`,
      version: 'timeout_optimized'
    };
    
  } catch (error) {
    console.error('Error in optimized autoSelectSingleOptions:', error);
    throw new Error(`Optimized auto-selection failed: ${error.toString()}`);
  }
}
function getCustomRange() {
  try {
    console.log('Fetching custom range C303:D330 from Sheet2...');
    const spreadsheet = getSpreadsheet();
    const sheet = spreadsheet.getSheetByName('Sheet2');
    
    if (!sheet) {
      throw new Error('Sheet2 not found');
    }
    
    const range = sheet.getRange('C303:D330');
    const values = range.getValues();
    
    const rows = [];
    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      if (row[0] || row[1]) {
        rows.push({
          rowNumber: 303 + i,
          colC: row[0] ? row[0].toString().trim() : '',
          colD: row[1] ? row[1].toString().trim() : ''
        });
      }
    }
    
    console.log(`Found ${rows.length} rows with data in C303:D330 range`);
    return { 
      success: true,
      rows: rows,
      range: 'C303:D330',
      sheet: 'Sheet2'
    };
  } catch (error) {
    console.error('Error getting custom range C303:D330:', error);
    return { 
      success: false,
      error: error.toString(), 
      rows: [],
      range: 'C303:D330',
      sheet: 'Sheet2'
    };
  }
}

function getApplicationTypes() {
  try {
    console.log('Fetching application types using getCustomRange...');
    const customRangeResult = getCustomRange();
    
    if (!customRangeResult.success) {
      throw new Error(customRangeResult.error);
    }
    
    const applicationTypes = [];
    
    for (let i = 0; i < customRangeResult.rows.length; i++) {
      const rowData = customRangeResult.rows[i];
      const name = rowData.colC;
      const description = rowData.colD;
      
      if (name && name.toString().trim() !== '' && description && description.toString().trim() !== '') {
        applicationTypes.push({
          name: name.toString().trim(),
          description: description.toString().trim()
        });
      }
    }
    
    console.log(`Found ${applicationTypes.length} application types`);
    return applicationTypes;
  } catch (error) {
    console.error('Error getting application types:', error);
    return [];
  }
}